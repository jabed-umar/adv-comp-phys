import numpy as np
import matplotlib.pyplot as plt

#Generate random number using Linear Congruential Generator
def lcg(seed: int, a: int, c: int, n: int, m: int = 2**32):
    '''
    Linear Congruential Generator
    # Parameters
    - seed: The seed value for the generator
    - a: Multiplier, range of 0 to m
    - c: Increment, range of 0 to m
    - m: Modulus, defines the range of the random numbers, default is 2^32
    - n: Number of random numbers to generate
    # Returns
    - A list of n random numbers
    '''
    random_numbers = []
    for i in range(n):
        seed = (a*seed + c) % m
        random_numbers.append(seed/m)   #it will generate random numbers between 0 to 1
    return random_numbers


# Do Monte Carlo Integration using the random numbers generated by LCG
def monte_carlo_integration(f, a: float, b: float, n: int, seed: int, a_lcg: int, c_lcg: int, m_lcg: int = 2**32):
    '''
    Monte Carlo Integration
    # Parameters
    f: The function to integrate
    - a: Lower limit of the integral
    - b: Upper limit of the integral
    - n: Number of random numbers to generate
    - seed: The seed value for the generator
    - a_lcg: Multiplier for LCG, range of 0 to m
    - c_lcg: Increment for LCG, range of 0 to m
    - m_lcg: Modulus for LCG, defines the range of the random numbers, default is 2^32
    # Returns
    - The value of the integral
    '''
    random_numbers = np.array(lcg(seed, a_lcg, c_lcg, n, m_lcg))
    integral = 0
    for i in random_numbers:
        integral += f(i*(b-a)+a)
    integral = (integral/n)*(b-a)
    return integral 


class Random:
    def __init__(self, seed: float = None, range: list = [0, 1]):
        if seed is None:
            import time 
            seed = int((time.time() * 1e4) % 10) / 10
            print(f"Seed not provided, using {seed = }.")
        self.seed = seed
        self.scale = lambda x: range[0] + x*(range[1]-range[0])

    def uniform(self, a, m):
        self.seed = (a*self.seed) % m
        return self.scale(self.seed / m)
    
class RandomDist(Random):
    def __init__(self, seed: float = None, f_inv: callable = lambda x: x, range=[0, 3]):
        super().__init__(seed)
        self.transform = f_inv
        self.range = range
    def invTransform(self, a=572, m=16381):
        while True:
            u = self.transform(self.uniform(a=a, m=m))
            if u >= self.range[0] and u <= self.range[1]:
                return u

# Do the Monte Carlo integration for given probability distribution function
def monte_carlo_integration_distribution(f, pdf, a: float, b: float, n: int, seed: int, a_lcg: int, c_lcg: int, m_lcg: int = 2**32):
    '''
    Monte Carlo Integration
    # Parameters
    f: The function to integrate
    pdf: The probability distribution function
    - a: Lower limit of the integral
    - b: Upper limit of the integral
    - n: Number of random numbers to generate
    - seed: The seed value for the generator
    - a_lcg: Multiplier for LCG, range of 0 to m
    - c_lcg: Increment for LCG, range of 0 to m
    - m_lcg: Modulus for LCG, defines the range of the random numbers, default is 2^32
    # Returns
    - The value of the integral
    '''
    random_numbers = np.array(lcg(seed, a_lcg, c_lcg, n, m_lcg))
    integral = 0
    for i in random_numbers:
        integral += f(i*(b-a)+a)/pdf(i*(b-a)+a)
    integral = (integral/n)
    return integral


class Random:  # better LCG implementation
    def __init__(self, func = lambda x: 1, limits=[0, 1], seed: float = None, silent=False, use_own=True):
        if seed is None:
            import time
            seed = int((time.time() * 1e4) % 10) / 10
            if not silent: print(f"Seed not provided, using {seed = }.")
        self.seed = seed
        self.func = func
        self.use_own = use_own
        self.scale = lambda x: limits[0] + x*(limits[1]-limits[0])
        if use_own:
            self.a = 1664525
            self.c = 1013904223
            self.m = 2**32
        else:
            np.random.seed(seed)

    def uniform(self, N, ):
        N = int(N)  # make sure it's an integer
        if self.use_own:
            ret = []
            for _ in range(N):
                self.seed = (self.a*self.seed + self.c) % self.m
                ret.append(self.seed / self.m)
            return np.array(ret)
        return np.random.rand(N)

    def accept_reject(self, N, margin=2):
        N = int(N)  # make sure it's an integer
        us = self.scale(self.uniform(margin*N))
        ps = self.uniform(margin*N)
        chosen = ps < self.func(us)
        return us[chosen][:N]

def monte_carlo_importance_integrate(ifunc, func, ps, limits):
    N = len(ps)

    rf1 = ps >= limits[0]
    rf2 = ps <= limits[1]
    ps = ps[rf1 & rf2]

    return (ifunc(ps)/func(ps)).sum() / N